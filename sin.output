Nonterminals useless in grammar

    sec_array
    matrix
    function


Terminals unused in grammar

    COM
    BCOM
    RETURN
    ARITOP
    FUN
    RELOP
    GROUP
    ARRAY
    BINOP
    FUNCTION


Rules useless in grammar

   79 sec_array: array COMMAN sec_array

   80 matrix: LR sec_array RR

   81 declare: ID LR DOUBLE RR LR DOUBLE RR ASIG matrix

   82 function: FUN ID LG id_sec RG LF END bloque RETURN expr_id RF
   83         | FUN ID LG id_sec RG LF END bloque RETURN expr RF
   84         | FUN ID LG id_sec RG LF END bloque RF


Rules useless in parser due to conflicts

   70 asig: ID ASIG ID


State 39 conflicts: 1 shift/reduce
State 70 conflicts: 2 reduce/reduce
State 71 conflicts: 7 reduce/reduce


Grammar

    0 $accept: prog $end

    1 prog: stmts

    2 stmts: %empty
    3      | stat END stmts
    4      | END stmts

    5 expr: expr ADD expr
    6     | expr SUB expr
    7     | expr MUL expr
    8     | expr DIV expr
    9     | expr POT expr
   10     | LG expr RG
   11     | SUB expr
   12     | DOUBLE

   13 expr_id: expr_id ADD expr_id
   14        | expr_id SUB expr_id
   15        | expr_id MUL expr_id
   16        | expr_id DIV expr_id
   17        | expr_id POT expr_id
   18        | LG expr_id RG
   19        | SUB expr_id
   20        | ID
   21        | DOUBLE

   22 stat: if_stat
   23     | for_stat
   24     | while_stat
   25     | print_stat
   26     | condition
   27     | declare
   28     | asig
   29     | cont
   30     | call_function
   31     | expr

   32 bloque: stat END bloque
   33       | %empty

   34 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont RG LF END bloque RF

   35 while_stat: WHILE LG condition RG LF END bloque RF

   36 print_stat: PRINT LG ID RG
   37           | PRINT LG expr RG

   38 condition: bool_cond AB AB condition
   39          | bool_cond OB OB condition
   40          | num_cond AB AB condition
   41          | num_cond OB OB condition
   42          | num_cond
   43          | bool_cond
   44          | TRUE

   45 bool_cond: ID
   46          | ID neq_eq TRUE
   47          | ID neq_eq FALSE
   48          | ID neq_eq ID

   49 neq_eq: EQ
   50       | NE

   51 num_cond: ID oper DOUBLE
   52         | ID oper ID

   53 oper: neq_eq
   54     | LT
   55     | LE
   56     | GE
   57     | GT

   58 cont: ADD ADD ID
   59     | SUB SUB ID
   60     | ID ADD ADD
   61     | ID SUB SUB

   62 sec_num: DOUBLE COMMAN sec_num
   63        | DOUBLE

   64 array: LR sec_num RR
   65      | LR RR

   66 declare: ID LR DOUBLE RR ASIG array
   67        | ID ASIG expr

   68 asig: ID LR DOUBLE RR LR DOUBLE RR ASIG expr
   69     | ID LR DOUBLE RR ASIG expr
   70     | ID ASIG ID
   71     | ID ASIG expr_id

   72 id_sec: ID COMMAN id_sec
   73       | ID
   74       | %empty

   75 call_function: ID LG id_sec RG
   76              | ID LG sec_num RG

   77 if_stat: IF LG condition RG LF END bloque RF ELSE LF END bloque RF
   78        | IF LG condition RG LF END bloque RF


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    IF (258) 77 78
    ELSE (259) 77
    ID <name> (260) 20 36 45 46 47 48 51 52 58 59 60 61 66 67 68 69 70 71 72 73 75 76
    DOUBLE <real> (261) 12 21 51 62 63 66 68 69
    FOR (262) 34
    WHILE (263) 35
    COM (264)
    BCOM (265)
    LT (266) 54
    LE (267) 55
    EQ (268) 49
    NE (269) 50
    GT (270) 57
    GE (271) 56
    PRINT (272) 36 37
    LG (273) 10 18 34 35 36 37 75 76 77 78
    RG (274) 10 18 34 35 36 37 75 76 77 78
    LR (275) 64 65 66 68 69
    RR (276) 64 65 66 68 69
    AB (277) 38 40
    OB (278) 39 41
    ADD (279) 5 13 58 60
    SUB (280) 6 11 14 19 59 61
    MUL (281) 7 15
    DIV (282) 8 16
    POT (283) 9 17
    FALSE (284) 47
    TRUE (285) 44 46
    LF (286) 34 35 77 78
    RF (287) 34 35 77 78
    ASIG (288) 66 67 68 69 70 71
    RETURN (289)
    ARITOP (290)
    FUN (291)
    RELOP (292)
    GROUP (293)
    ARRAY (294)
    BINOP (295)
    FUNCTION (296)
    SEMICOLON (297) 34
    COMMAN (298) 62 72
    END (299) 3 4 32 34 35 77 78
    UMINUS (300)


Nonterminals, with rules where they appear

    $accept (46)
        on left: 0
    prog (47)
        on left: 1
        on right: 0
    stmts (48)
        on left: 2 3 4
        on right: 1 3 4
    expr <real> (49)
        on left: 5 6 7 8 9 10 11 12
        on right: 5 6 7 8 9 10 11 31 37 67 68 69
    expr_id (50)
        on left: 13 14 15 16 17 18 19 20 21
        on right: 13 14 15 16 17 18 19 71
    stat (51)
        on left: 22 23 24 25 26 27 28 29 30 31
        on right: 3 32
    bloque (52)
        on left: 32 33
        on right: 32 34 35 77 78
    for_stat (53)
        on left: 34
        on right: 23
    while_stat (54)
        on left: 35
        on right: 24
    print_stat (55)
        on left: 36 37
        on right: 25
    condition (56)
        on left: 38 39 40 41 42 43 44
        on right: 26 34 35 38 39 40 41 77 78
    bool_cond (57)
        on left: 45 46 47 48
        on right: 38 39 43
    neq_eq (58)
        on left: 49 50
        on right: 46 47 48 53
    num_cond (59)
        on left: 51 52
        on right: 40 41 42
    oper (60)
        on left: 53 54 55 56 57
        on right: 51 52
    cont (61)
        on left: 58 59 60 61
        on right: 29 34
    sec_num (62)
        on left: 62 63
        on right: 62 64 76
    array (63)
        on left: 64 65
        on right: 66
    declare (64)
        on left: 66 67
        on right: 27
    asig (65)
        on left: 68 69 70 71
        on right: 28 34
    id_sec (66)
        on left: 72 73 74
        on right: 72 75
    call_function (67)
        on left: 75 76
        on right: 30
    if_stat (68)
        on left: 77 78
        on right: 22


State 0

    0 $accept: . prog $end

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10
    END     shift, and go to state 11

    $default  reduce using rule 2 (stmts)

    prog           go to state 12
    stmts          go to state 13
    expr           go to state 14
    stat           go to state 15
    for_stat       go to state 16
    while_stat     go to state 17
    print_stat     go to state 18
    condition      go to state 19
    bool_cond      go to state 20
    num_cond       go to state 21
    cont           go to state 22
    declare        go to state 23
    asig           go to state 24
    call_function  go to state 25
    if_stat        go to state 26


State 1

   77 if_stat: IF . LG condition RG LF END bloque RF ELSE LF END bloque RF
   78        | IF . LG condition RG LF END bloque RF

    LG  shift, and go to state 27


State 2

   45 bool_cond: ID .
   46          | ID . neq_eq TRUE
   47          | ID . neq_eq FALSE
   48          | ID . neq_eq ID
   51 num_cond: ID . oper DOUBLE
   52         | ID . oper ID
   60 cont: ID . ADD ADD
   61     | ID . SUB SUB
   66 declare: ID . LR DOUBLE RR ASIG array
   67        | ID . ASIG expr
   68 asig: ID . LR DOUBLE RR LR DOUBLE RR ASIG expr
   69     | ID . LR DOUBLE RR ASIG expr
   70     | ID . ASIG ID
   71     | ID . ASIG expr_id
   75 call_function: ID . LG id_sec RG
   76              | ID . LG sec_num RG

    LT    shift, and go to state 28
    LE    shift, and go to state 29
    EQ    shift, and go to state 30
    NE    shift, and go to state 31
    GT    shift, and go to state 32
    GE    shift, and go to state 33
    LG    shift, and go to state 34
    LR    shift, and go to state 35
    ADD   shift, and go to state 36
    SUB   shift, and go to state 37
    ASIG  shift, and go to state 38

    $default  reduce using rule 45 (bool_cond)

    neq_eq  go to state 39
    oper    go to state 40


State 3

   12 expr: DOUBLE .

    $default  reduce using rule 12 (expr)


State 4

   34 for_stat: FOR . LG asig SEMICOLON condition SEMICOLON cont RG LF END bloque RF

    LG  shift, and go to state 41


State 5

   35 while_stat: WHILE . LG condition RG LF END bloque RF

    LG  shift, and go to state 42


State 6

   36 print_stat: PRINT . LG ID RG
   37           | PRINT . LG expr RG

    LG  shift, and go to state 43


State 7

   10 expr: LG . expr RG

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 44

    expr  go to state 45


State 8

   58 cont: ADD . ADD ID

    ADD  shift, and go to state 46


State 9

   11 expr: SUB . expr
   59 cont: SUB . SUB ID

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 47

    expr  go to state 48


State 10

   44 condition: TRUE .

    $default  reduce using rule 44 (condition)


State 11

    4 stmts: END . stmts

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10
    END     shift, and go to state 11

    $default  reduce using rule 2 (stmts)

    stmts          go to state 49
    expr           go to state 14
    stat           go to state 15
    for_stat       go to state 16
    while_stat     go to state 17
    print_stat     go to state 18
    condition      go to state 19
    bool_cond      go to state 20
    num_cond       go to state 21
    cont           go to state 22
    declare        go to state 23
    asig           go to state 24
    call_function  go to state 25
    if_stat        go to state 26


State 12

    0 $accept: prog . $end

    $end  shift, and go to state 50


State 13

    1 prog: stmts .

    $default  reduce using rule 1 (prog)


State 14

    5 expr: expr . ADD expr
    6     | expr . SUB expr
    7     | expr . MUL expr
    8     | expr . DIV expr
    9     | expr . POT expr
   31 stat: expr .

    ADD  shift, and go to state 51
    SUB  shift, and go to state 52
    MUL  shift, and go to state 53
    DIV  shift, and go to state 54
    POT  shift, and go to state 55

    $default  reduce using rule 31 (stat)


State 15

    3 stmts: stat . END stmts

    END  shift, and go to state 56


State 16

   23 stat: for_stat .

    $default  reduce using rule 23 (stat)


State 17

   24 stat: while_stat .

    $default  reduce using rule 24 (stat)


State 18

   25 stat: print_stat .

    $default  reduce using rule 25 (stat)


State 19

   26 stat: condition .

    $default  reduce using rule 26 (stat)


State 20

   38 condition: bool_cond . AB AB condition
   39          | bool_cond . OB OB condition
   43          | bool_cond .

    AB  shift, and go to state 57
    OB  shift, and go to state 58

    $default  reduce using rule 43 (condition)


State 21

   40 condition: num_cond . AB AB condition
   41          | num_cond . OB OB condition
   42          | num_cond .

    AB  shift, and go to state 59
    OB  shift, and go to state 60

    $default  reduce using rule 42 (condition)


State 22

   29 stat: cont .

    $default  reduce using rule 29 (stat)


State 23

   27 stat: declare .

    $default  reduce using rule 27 (stat)


State 24

   28 stat: asig .

    $default  reduce using rule 28 (stat)


State 25

   30 stat: call_function .

    $default  reduce using rule 30 (stat)


State 26

   22 stat: if_stat .

    $default  reduce using rule 22 (stat)


State 27

   77 if_stat: IF LG . condition RG LF END bloque RF ELSE LF END bloque RF
   78        | IF LG . condition RG LF END bloque RF

    ID    shift, and go to state 61
    TRUE  shift, and go to state 10

    condition  go to state 62
    bool_cond  go to state 20
    num_cond   go to state 21


State 28

   54 oper: LT .

    $default  reduce using rule 54 (oper)


State 29

   55 oper: LE .

    $default  reduce using rule 55 (oper)


State 30

   49 neq_eq: EQ .

    $default  reduce using rule 49 (neq_eq)


State 31

   50 neq_eq: NE .

    $default  reduce using rule 50 (neq_eq)


State 32

   57 oper: GT .

    $default  reduce using rule 57 (oper)


State 33

   56 oper: GE .

    $default  reduce using rule 56 (oper)


State 34

   75 call_function: ID LG . id_sec RG
   76              | ID LG . sec_num RG

    ID      shift, and go to state 63
    DOUBLE  shift, and go to state 64

    $default  reduce using rule 74 (id_sec)

    sec_num  go to state 65
    id_sec   go to state 66


State 35

   66 declare: ID LR . DOUBLE RR ASIG array
   68 asig: ID LR . DOUBLE RR LR DOUBLE RR ASIG expr
   69     | ID LR . DOUBLE RR ASIG expr

    DOUBLE  shift, and go to state 67


State 36

   60 cont: ID ADD . ADD

    ADD  shift, and go to state 68


State 37

   61 cont: ID SUB . SUB

    SUB  shift, and go to state 69


State 38

   67 declare: ID ASIG . expr
   70 asig: ID ASIG . ID
   71     | ID ASIG . expr_id

    ID      shift, and go to state 70
    DOUBLE  shift, and go to state 71
    LG      shift, and go to state 72
    SUB     shift, and go to state 73

    expr     go to state 74
    expr_id  go to state 75


State 39

   46 bool_cond: ID neq_eq . TRUE
   47          | ID neq_eq . FALSE
   48          | ID neq_eq . ID
   53 oper: neq_eq .

    ID     shift, and go to state 76
    FALSE  shift, and go to state 77
    TRUE   shift, and go to state 78

    ID        [reduce using rule 53 (oper)]
    $default  reduce using rule 53 (oper)


State 40

   51 num_cond: ID oper . DOUBLE
   52         | ID oper . ID

    ID      shift, and go to state 79
    DOUBLE  shift, and go to state 80


State 41

   34 for_stat: FOR LG . asig SEMICOLON condition SEMICOLON cont RG LF END bloque RF

    ID  shift, and go to state 81

    asig  go to state 82


State 42

   35 while_stat: WHILE LG . condition RG LF END bloque RF

    ID    shift, and go to state 61
    TRUE  shift, and go to state 10

    condition  go to state 83
    bool_cond  go to state 20
    num_cond   go to state 21


State 43

   36 print_stat: PRINT LG . ID RG
   37           | PRINT LG . expr RG

    ID      shift, and go to state 84
    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 44

    expr  go to state 85


State 44

   11 expr: SUB . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 44

    expr  go to state 48


State 45

    5 expr: expr . ADD expr
    6     | expr . SUB expr
    7     | expr . MUL expr
    8     | expr . DIV expr
    9     | expr . POT expr
   10     | LG expr . RG

    RG   shift, and go to state 86
    ADD  shift, and go to state 51
    SUB  shift, and go to state 52
    MUL  shift, and go to state 53
    DIV  shift, and go to state 54
    POT  shift, and go to state 55


State 46

   58 cont: ADD ADD . ID

    ID  shift, and go to state 87


State 47

   11 expr: SUB . expr
   59 cont: SUB SUB . ID

    ID      shift, and go to state 88
    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 44

    expr  go to state 48


State 48

    5 expr: expr . ADD expr
    6     | expr . SUB expr
    7     | expr . MUL expr
    8     | expr . DIV expr
    9     | expr . POT expr
   11     | SUB expr .

    $default  reduce using rule 11 (expr)


State 49

    4 stmts: END stmts .

    $default  reduce using rule 4 (stmts)


State 50

    0 $accept: prog $end .

    $default  accept


State 51

    5 expr: expr ADD . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 44

    expr  go to state 89


State 52

    6 expr: expr SUB . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 44

    expr  go to state 90


State 53

    7 expr: expr MUL . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 44

    expr  go to state 91


State 54

    8 expr: expr DIV . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 44

    expr  go to state 92


State 55

    9 expr: expr POT . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 44

    expr  go to state 93


State 56

    3 stmts: stat END . stmts

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10
    END     shift, and go to state 11

    $default  reduce using rule 2 (stmts)

    stmts          go to state 94
    expr           go to state 14
    stat           go to state 15
    for_stat       go to state 16
    while_stat     go to state 17
    print_stat     go to state 18
    condition      go to state 19
    bool_cond      go to state 20
    num_cond       go to state 21
    cont           go to state 22
    declare        go to state 23
    asig           go to state 24
    call_function  go to state 25
    if_stat        go to state 26


State 57

   38 condition: bool_cond AB . AB condition

    AB  shift, and go to state 95


State 58

   39 condition: bool_cond OB . OB condition

    OB  shift, and go to state 96


State 59

   40 condition: num_cond AB . AB condition

    AB  shift, and go to state 97


State 60

   41 condition: num_cond OB . OB condition

    OB  shift, and go to state 98


State 61

   45 bool_cond: ID .
   46          | ID . neq_eq TRUE
   47          | ID . neq_eq FALSE
   48          | ID . neq_eq ID
   51 num_cond: ID . oper DOUBLE
   52         | ID . oper ID

    LT  shift, and go to state 28
    LE  shift, and go to state 29
    EQ  shift, and go to state 30
    NE  shift, and go to state 31
    GT  shift, and go to state 32
    GE  shift, and go to state 33

    $default  reduce using rule 45 (bool_cond)

    neq_eq  go to state 39
    oper    go to state 40


State 62

   77 if_stat: IF LG condition . RG LF END bloque RF ELSE LF END bloque RF
   78        | IF LG condition . RG LF END bloque RF

    RG  shift, and go to state 99


State 63

   72 id_sec: ID . COMMAN id_sec
   73       | ID .

    COMMAN  shift, and go to state 100

    $default  reduce using rule 73 (id_sec)


State 64

   62 sec_num: DOUBLE . COMMAN sec_num
   63        | DOUBLE .

    COMMAN  shift, and go to state 101

    $default  reduce using rule 63 (sec_num)


State 65

   76 call_function: ID LG sec_num . RG

    RG  shift, and go to state 102


State 66

   75 call_function: ID LG id_sec . RG

    RG  shift, and go to state 103


State 67

   66 declare: ID LR DOUBLE . RR ASIG array
   68 asig: ID LR DOUBLE . RR LR DOUBLE RR ASIG expr
   69     | ID LR DOUBLE . RR ASIG expr

    RR  shift, and go to state 104


State 68

   60 cont: ID ADD ADD .

    $default  reduce using rule 60 (cont)


State 69

   61 cont: ID SUB SUB .

    $default  reduce using rule 61 (cont)


State 70

   20 expr_id: ID .
   70 asig: ID ASIG ID .

    SEMICOLON  reduce using rule 20 (expr_id)
    SEMICOLON  [reduce using rule 70 (asig)]
    END        reduce using rule 20 (expr_id)
    END        [reduce using rule 70 (asig)]
    $default   reduce using rule 20 (expr_id)


State 71

   12 expr: DOUBLE .
   21 expr_id: DOUBLE .

    RG        reduce using rule 12 (expr)
    RG        [reduce using rule 21 (expr_id)]
    ADD       reduce using rule 12 (expr)
    ADD       [reduce using rule 21 (expr_id)]
    SUB       reduce using rule 12 (expr)
    SUB       [reduce using rule 21 (expr_id)]
    MUL       reduce using rule 12 (expr)
    MUL       [reduce using rule 21 (expr_id)]
    DIV       reduce using rule 12 (expr)
    DIV       [reduce using rule 21 (expr_id)]
    POT       reduce using rule 12 (expr)
    POT       [reduce using rule 21 (expr_id)]
    END       reduce using rule 12 (expr)
    END       [reduce using rule 21 (expr_id)]
    $default  reduce using rule 12 (expr)


State 72

   10 expr: LG . expr RG
   18 expr_id: LG . expr_id RG

    ID      shift, and go to state 105
    DOUBLE  shift, and go to state 71
    LG      shift, and go to state 72
    SUB     shift, and go to state 73

    expr     go to state 45
    expr_id  go to state 106


State 73

   11 expr: SUB . expr
   19 expr_id: SUB . expr_id

    ID      shift, and go to state 105
    DOUBLE  shift, and go to state 71
    LG      shift, and go to state 72
    SUB     shift, and go to state 73

    expr     go to state 48
    expr_id  go to state 107


State 74

    5 expr: expr . ADD expr
    6     | expr . SUB expr
    7     | expr . MUL expr
    8     | expr . DIV expr
    9     | expr . POT expr
   67 declare: ID ASIG expr .

    ADD  shift, and go to state 51
    SUB  shift, and go to state 52
    MUL  shift, and go to state 53
    DIV  shift, and go to state 54
    POT  shift, and go to state 55

    $default  reduce using rule 67 (declare)


State 75

   13 expr_id: expr_id . ADD expr_id
   14        | expr_id . SUB expr_id
   15        | expr_id . MUL expr_id
   16        | expr_id . DIV expr_id
   17        | expr_id . POT expr_id
   71 asig: ID ASIG expr_id .

    ADD  shift, and go to state 108
    SUB  shift, and go to state 109
    MUL  shift, and go to state 110
    DIV  shift, and go to state 111
    POT  shift, and go to state 112

    $default  reduce using rule 71 (asig)


State 76

   48 bool_cond: ID neq_eq ID .

    $default  reduce using rule 48 (bool_cond)


State 77

   47 bool_cond: ID neq_eq FALSE .

    $default  reduce using rule 47 (bool_cond)


State 78

   46 bool_cond: ID neq_eq TRUE .

    $default  reduce using rule 46 (bool_cond)


State 79

   52 num_cond: ID oper ID .

    $default  reduce using rule 52 (num_cond)


State 80

   51 num_cond: ID oper DOUBLE .

    $default  reduce using rule 51 (num_cond)


State 81

   68 asig: ID . LR DOUBLE RR LR DOUBLE RR ASIG expr
   69     | ID . LR DOUBLE RR ASIG expr
   70     | ID . ASIG ID
   71     | ID . ASIG expr_id

    LR    shift, and go to state 113
    ASIG  shift, and go to state 114


State 82

   34 for_stat: FOR LG asig . SEMICOLON condition SEMICOLON cont RG LF END bloque RF

    SEMICOLON  shift, and go to state 115


State 83

   35 while_stat: WHILE LG condition . RG LF END bloque RF

    RG  shift, and go to state 116


State 84

   36 print_stat: PRINT LG ID . RG

    RG  shift, and go to state 117


State 85

    5 expr: expr . ADD expr
    6     | expr . SUB expr
    7     | expr . MUL expr
    8     | expr . DIV expr
    9     | expr . POT expr
   37 print_stat: PRINT LG expr . RG

    RG   shift, and go to state 118
    ADD  shift, and go to state 51
    SUB  shift, and go to state 52
    MUL  shift, and go to state 53
    DIV  shift, and go to state 54
    POT  shift, and go to state 55


State 86

   10 expr: LG expr RG .

    $default  reduce using rule 10 (expr)


State 87

   58 cont: ADD ADD ID .

    $default  reduce using rule 58 (cont)


State 88

   59 cont: SUB SUB ID .

    $default  reduce using rule 59 (cont)


State 89

    5 expr: expr . ADD expr
    5     | expr ADD expr .
    6     | expr . SUB expr
    7     | expr . MUL expr
    8     | expr . DIV expr
    9     | expr . POT expr

    MUL  shift, and go to state 53
    DIV  shift, and go to state 54
    POT  shift, and go to state 55

    $default  reduce using rule 5 (expr)


State 90

    5 expr: expr . ADD expr
    6     | expr . SUB expr
    6     | expr SUB expr .
    7     | expr . MUL expr
    8     | expr . DIV expr
    9     | expr . POT expr

    MUL  shift, and go to state 53
    DIV  shift, and go to state 54
    POT  shift, and go to state 55

    $default  reduce using rule 6 (expr)


State 91

    5 expr: expr . ADD expr
    6     | expr . SUB expr
    7     | expr . MUL expr
    7     | expr MUL expr .
    8     | expr . DIV expr
    9     | expr . POT expr

    POT  shift, and go to state 55

    $default  reduce using rule 7 (expr)


State 92

    5 expr: expr . ADD expr
    6     | expr . SUB expr
    7     | expr . MUL expr
    8     | expr . DIV expr
    8     | expr DIV expr .
    9     | expr . POT expr

    POT  shift, and go to state 55

    $default  reduce using rule 8 (expr)


State 93

    5 expr: expr . ADD expr
    6     | expr . SUB expr
    7     | expr . MUL expr
    8     | expr . DIV expr
    9     | expr . POT expr
    9     | expr POT expr .

    POT  shift, and go to state 55

    $default  reduce using rule 9 (expr)


State 94

    3 stmts: stat END stmts .

    $default  reduce using rule 3 (stmts)


State 95

   38 condition: bool_cond AB AB . condition

    ID    shift, and go to state 61
    TRUE  shift, and go to state 10

    condition  go to state 119
    bool_cond  go to state 20
    num_cond   go to state 21


State 96

   39 condition: bool_cond OB OB . condition

    ID    shift, and go to state 61
    TRUE  shift, and go to state 10

    condition  go to state 120
    bool_cond  go to state 20
    num_cond   go to state 21


State 97

   40 condition: num_cond AB AB . condition

    ID    shift, and go to state 61
    TRUE  shift, and go to state 10

    condition  go to state 121
    bool_cond  go to state 20
    num_cond   go to state 21


State 98

   41 condition: num_cond OB OB . condition

    ID    shift, and go to state 61
    TRUE  shift, and go to state 10

    condition  go to state 122
    bool_cond  go to state 20
    num_cond   go to state 21


State 99

   77 if_stat: IF LG condition RG . LF END bloque RF ELSE LF END bloque RF
   78        | IF LG condition RG . LF END bloque RF

    LF  shift, and go to state 123


State 100

   72 id_sec: ID COMMAN . id_sec

    ID  shift, and go to state 63

    $default  reduce using rule 74 (id_sec)

    id_sec  go to state 124


State 101

   62 sec_num: DOUBLE COMMAN . sec_num

    DOUBLE  shift, and go to state 64

    sec_num  go to state 125


State 102

   76 call_function: ID LG sec_num RG .

    $default  reduce using rule 76 (call_function)


State 103

   75 call_function: ID LG id_sec RG .

    $default  reduce using rule 75 (call_function)


State 104

   66 declare: ID LR DOUBLE RR . ASIG array
   68 asig: ID LR DOUBLE RR . LR DOUBLE RR ASIG expr
   69     | ID LR DOUBLE RR . ASIG expr

    LR    shift, and go to state 126
    ASIG  shift, and go to state 127


State 105

   20 expr_id: ID .

    $default  reduce using rule 20 (expr_id)


State 106

   13 expr_id: expr_id . ADD expr_id
   14        | expr_id . SUB expr_id
   15        | expr_id . MUL expr_id
   16        | expr_id . DIV expr_id
   17        | expr_id . POT expr_id
   18        | LG expr_id . RG

    RG   shift, and go to state 128
    ADD  shift, and go to state 108
    SUB  shift, and go to state 109
    MUL  shift, and go to state 110
    DIV  shift, and go to state 111
    POT  shift, and go to state 112


State 107

   13 expr_id: expr_id . ADD expr_id
   14        | expr_id . SUB expr_id
   15        | expr_id . MUL expr_id
   16        | expr_id . DIV expr_id
   17        | expr_id . POT expr_id
   19        | SUB expr_id .

    $default  reduce using rule 19 (expr_id)


State 108

   13 expr_id: expr_id ADD . expr_id

    ID      shift, and go to state 105
    DOUBLE  shift, and go to state 129
    LG      shift, and go to state 130
    SUB     shift, and go to state 131

    expr_id  go to state 132


State 109

   14 expr_id: expr_id SUB . expr_id

    ID      shift, and go to state 105
    DOUBLE  shift, and go to state 129
    LG      shift, and go to state 130
    SUB     shift, and go to state 131

    expr_id  go to state 133


State 110

   15 expr_id: expr_id MUL . expr_id

    ID      shift, and go to state 105
    DOUBLE  shift, and go to state 129
    LG      shift, and go to state 130
    SUB     shift, and go to state 131

    expr_id  go to state 134


State 111

   16 expr_id: expr_id DIV . expr_id

    ID      shift, and go to state 105
    DOUBLE  shift, and go to state 129
    LG      shift, and go to state 130
    SUB     shift, and go to state 131

    expr_id  go to state 135


State 112

   17 expr_id: expr_id POT . expr_id

    ID      shift, and go to state 105
    DOUBLE  shift, and go to state 129
    LG      shift, and go to state 130
    SUB     shift, and go to state 131

    expr_id  go to state 136


State 113

   68 asig: ID LR . DOUBLE RR LR DOUBLE RR ASIG expr
   69     | ID LR . DOUBLE RR ASIG expr

    DOUBLE  shift, and go to state 137


State 114

   70 asig: ID ASIG . ID
   71     | ID ASIG . expr_id

    ID      shift, and go to state 70
    DOUBLE  shift, and go to state 129
    LG      shift, and go to state 130
    SUB     shift, and go to state 131

    expr_id  go to state 75


State 115

   34 for_stat: FOR LG asig SEMICOLON . condition SEMICOLON cont RG LF END bloque RF

    ID    shift, and go to state 61
    TRUE  shift, and go to state 10

    condition  go to state 138
    bool_cond  go to state 20
    num_cond   go to state 21


State 116

   35 while_stat: WHILE LG condition RG . LF END bloque RF

    LF  shift, and go to state 139


State 117

   36 print_stat: PRINT LG ID RG .

    $default  reduce using rule 36 (print_stat)


State 118

   37 print_stat: PRINT LG expr RG .

    $default  reduce using rule 37 (print_stat)


State 119

   38 condition: bool_cond AB AB condition .

    $default  reduce using rule 38 (condition)


State 120

   39 condition: bool_cond OB OB condition .

    $default  reduce using rule 39 (condition)


State 121

   40 condition: num_cond AB AB condition .

    $default  reduce using rule 40 (condition)


State 122

   41 condition: num_cond OB OB condition .

    $default  reduce using rule 41 (condition)


State 123

   77 if_stat: IF LG condition RG LF . END bloque RF ELSE LF END bloque RF
   78        | IF LG condition RG LF . END bloque RF

    END  shift, and go to state 140


State 124

   72 id_sec: ID COMMAN id_sec .

    $default  reduce using rule 72 (id_sec)


State 125

   62 sec_num: DOUBLE COMMAN sec_num .

    $default  reduce using rule 62 (sec_num)


State 126

   68 asig: ID LR DOUBLE RR LR . DOUBLE RR ASIG expr

    DOUBLE  shift, and go to state 141


State 127

   66 declare: ID LR DOUBLE RR ASIG . array
   69 asig: ID LR DOUBLE RR ASIG . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    LR      shift, and go to state 142
    SUB     shift, and go to state 44

    expr   go to state 143
    array  go to state 144


State 128

   18 expr_id: LG expr_id RG .

    $default  reduce using rule 18 (expr_id)


State 129

   21 expr_id: DOUBLE .

    $default  reduce using rule 21 (expr_id)


State 130

   18 expr_id: LG . expr_id RG

    ID      shift, and go to state 105
    DOUBLE  shift, and go to state 129
    LG      shift, and go to state 130
    SUB     shift, and go to state 131

    expr_id  go to state 106


State 131

   19 expr_id: SUB . expr_id

    ID      shift, and go to state 105
    DOUBLE  shift, and go to state 129
    LG      shift, and go to state 130
    SUB     shift, and go to state 131

    expr_id  go to state 107


State 132

   13 expr_id: expr_id . ADD expr_id
   13        | expr_id ADD expr_id .
   14        | expr_id . SUB expr_id
   15        | expr_id . MUL expr_id
   16        | expr_id . DIV expr_id
   17        | expr_id . POT expr_id

    MUL  shift, and go to state 110
    DIV  shift, and go to state 111
    POT  shift, and go to state 112

    $default  reduce using rule 13 (expr_id)


State 133

   13 expr_id: expr_id . ADD expr_id
   14        | expr_id . SUB expr_id
   14        | expr_id SUB expr_id .
   15        | expr_id . MUL expr_id
   16        | expr_id . DIV expr_id
   17        | expr_id . POT expr_id

    MUL  shift, and go to state 110
    DIV  shift, and go to state 111
    POT  shift, and go to state 112

    $default  reduce using rule 14 (expr_id)


State 134

   13 expr_id: expr_id . ADD expr_id
   14        | expr_id . SUB expr_id
   15        | expr_id . MUL expr_id
   15        | expr_id MUL expr_id .
   16        | expr_id . DIV expr_id
   17        | expr_id . POT expr_id

    POT  shift, and go to state 112

    $default  reduce using rule 15 (expr_id)


State 135

   13 expr_id: expr_id . ADD expr_id
   14        | expr_id . SUB expr_id
   15        | expr_id . MUL expr_id
   16        | expr_id . DIV expr_id
   16        | expr_id DIV expr_id .
   17        | expr_id . POT expr_id

    POT  shift, and go to state 112

    $default  reduce using rule 16 (expr_id)


State 136

   13 expr_id: expr_id . ADD expr_id
   14        | expr_id . SUB expr_id
   15        | expr_id . MUL expr_id
   16        | expr_id . DIV expr_id
   17        | expr_id . POT expr_id
   17        | expr_id POT expr_id .

    POT  shift, and go to state 112

    $default  reduce using rule 17 (expr_id)


State 137

   68 asig: ID LR DOUBLE . RR LR DOUBLE RR ASIG expr
   69     | ID LR DOUBLE . RR ASIG expr

    RR  shift, and go to state 145


State 138

   34 for_stat: FOR LG asig SEMICOLON condition . SEMICOLON cont RG LF END bloque RF

    SEMICOLON  shift, and go to state 146


State 139

   35 while_stat: WHILE LG condition RG LF . END bloque RF

    END  shift, and go to state 147


State 140

   77 if_stat: IF LG condition RG LF END . bloque RF ELSE LF END bloque RF
   78        | IF LG condition RG LF END . bloque RF

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10

    $default  reduce using rule 33 (bloque)

    expr           go to state 14
    stat           go to state 148
    bloque         go to state 149
    for_stat       go to state 16
    while_stat     go to state 17
    print_stat     go to state 18
    condition      go to state 19
    bool_cond      go to state 20
    num_cond       go to state 21
    cont           go to state 22
    declare        go to state 23
    asig           go to state 24
    call_function  go to state 25
    if_stat        go to state 26


State 141

   68 asig: ID LR DOUBLE RR LR DOUBLE . RR ASIG expr

    RR  shift, and go to state 150


State 142

   64 array: LR . sec_num RR
   65      | LR . RR

    DOUBLE  shift, and go to state 64
    RR      shift, and go to state 151

    sec_num  go to state 152


State 143

    5 expr: expr . ADD expr
    6     | expr . SUB expr
    7     | expr . MUL expr
    8     | expr . DIV expr
    9     | expr . POT expr
   69 asig: ID LR DOUBLE RR ASIG expr .

    ADD  shift, and go to state 51
    SUB  shift, and go to state 52
    MUL  shift, and go to state 53
    DIV  shift, and go to state 54
    POT  shift, and go to state 55

    $default  reduce using rule 69 (asig)


State 144

   66 declare: ID LR DOUBLE RR ASIG array .

    $default  reduce using rule 66 (declare)


State 145

   68 asig: ID LR DOUBLE RR . LR DOUBLE RR ASIG expr
   69     | ID LR DOUBLE RR . ASIG expr

    LR    shift, and go to state 126
    ASIG  shift, and go to state 153


State 146

   34 for_stat: FOR LG asig SEMICOLON condition SEMICOLON . cont RG LF END bloque RF

    ID   shift, and go to state 154
    ADD  shift, and go to state 8
    SUB  shift, and go to state 155

    cont  go to state 156


State 147

   35 while_stat: WHILE LG condition RG LF END . bloque RF

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10

    $default  reduce using rule 33 (bloque)

    expr           go to state 14
    stat           go to state 148
    bloque         go to state 157
    for_stat       go to state 16
    while_stat     go to state 17
    print_stat     go to state 18
    condition      go to state 19
    bool_cond      go to state 20
    num_cond       go to state 21
    cont           go to state 22
    declare        go to state 23
    asig           go to state 24
    call_function  go to state 25
    if_stat        go to state 26


State 148

   32 bloque: stat . END bloque

    END  shift, and go to state 158


State 149

   77 if_stat: IF LG condition RG LF END bloque . RF ELSE LF END bloque RF
   78        | IF LG condition RG LF END bloque . RF

    RF  shift, and go to state 159


State 150

   68 asig: ID LR DOUBLE RR LR DOUBLE RR . ASIG expr

    ASIG  shift, and go to state 160


State 151

   65 array: LR RR .

    $default  reduce using rule 65 (array)


State 152

   64 array: LR sec_num . RR

    RR  shift, and go to state 161


State 153

   69 asig: ID LR DOUBLE RR ASIG . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 44

    expr  go to state 143


State 154

   60 cont: ID . ADD ADD
   61     | ID . SUB SUB

    ADD  shift, and go to state 36
    SUB  shift, and go to state 37


State 155

   59 cont: SUB . SUB ID

    SUB  shift, and go to state 162


State 156

   34 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont . RG LF END bloque RF

    RG  shift, and go to state 163


State 157

   35 while_stat: WHILE LG condition RG LF END bloque . RF

    RF  shift, and go to state 164


State 158

   32 bloque: stat END . bloque

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10

    $default  reduce using rule 33 (bloque)

    expr           go to state 14
    stat           go to state 148
    bloque         go to state 165
    for_stat       go to state 16
    while_stat     go to state 17
    print_stat     go to state 18
    condition      go to state 19
    bool_cond      go to state 20
    num_cond       go to state 21
    cont           go to state 22
    declare        go to state 23
    asig           go to state 24
    call_function  go to state 25
    if_stat        go to state 26


State 159

   77 if_stat: IF LG condition RG LF END bloque RF . ELSE LF END bloque RF
   78        | IF LG condition RG LF END bloque RF .

    ELSE  shift, and go to state 166

    $default  reduce using rule 78 (if_stat)


State 160

   68 asig: ID LR DOUBLE RR LR DOUBLE RR ASIG . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 44

    expr  go to state 167


State 161

   64 array: LR sec_num RR .

    $default  reduce using rule 64 (array)


State 162

   59 cont: SUB SUB . ID

    ID  shift, and go to state 88


State 163

   34 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont RG . LF END bloque RF

    LF  shift, and go to state 168


State 164

   35 while_stat: WHILE LG condition RG LF END bloque RF .

    $default  reduce using rule 35 (while_stat)


State 165

   32 bloque: stat END bloque .

    $default  reduce using rule 32 (bloque)


State 166

   77 if_stat: IF LG condition RG LF END bloque RF ELSE . LF END bloque RF

    LF  shift, and go to state 169


State 167

    5 expr: expr . ADD expr
    6     | expr . SUB expr
    7     | expr . MUL expr
    8     | expr . DIV expr
    9     | expr . POT expr
   68 asig: ID LR DOUBLE RR LR DOUBLE RR ASIG expr .

    ADD  shift, and go to state 51
    SUB  shift, and go to state 52
    MUL  shift, and go to state 53
    DIV  shift, and go to state 54
    POT  shift, and go to state 55

    $default  reduce using rule 68 (asig)


State 168

   34 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont RG LF . END bloque RF

    END  shift, and go to state 170


State 169

   77 if_stat: IF LG condition RG LF END bloque RF ELSE LF . END bloque RF

    END  shift, and go to state 171


State 170

   34 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont RG LF END . bloque RF

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10

    $default  reduce using rule 33 (bloque)

    expr           go to state 14
    stat           go to state 148
    bloque         go to state 172
    for_stat       go to state 16
    while_stat     go to state 17
    print_stat     go to state 18
    condition      go to state 19
    bool_cond      go to state 20
    num_cond       go to state 21
    cont           go to state 22
    declare        go to state 23
    asig           go to state 24
    call_function  go to state 25
    if_stat        go to state 26


State 171

   77 if_stat: IF LG condition RG LF END bloque RF ELSE LF END . bloque RF

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10

    $default  reduce using rule 33 (bloque)

    expr           go to state 14
    stat           go to state 148
    bloque         go to state 173
    for_stat       go to state 16
    while_stat     go to state 17
    print_stat     go to state 18
    condition      go to state 19
    bool_cond      go to state 20
    num_cond       go to state 21
    cont           go to state 22
    declare        go to state 23
    asig           go to state 24
    call_function  go to state 25
    if_stat        go to state 26


State 172

   34 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont RG LF END bloque . RF

    RF  shift, and go to state 174


State 173

   77 if_stat: IF LG condition RG LF END bloque RF ELSE LF END bloque . RF

    RF  shift, and go to state 175


State 174

   34 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont RG LF END bloque RF .

    $default  reduce using rule 34 (for_stat)


State 175

   77 if_stat: IF LG condition RG LF END bloque RF ELSE LF END bloque RF .

    $default  reduce using rule 77 (if_stat)
