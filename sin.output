Nonterminals useless in grammar

    sec_array
    matrix


Terminals unused in grammar

    COM
    BCOM
    ARITOP
    RELOP
    GROUP
    ARRAY
    BINOP
    FUNCTION


Rules useless in grammar

   84 sec_array: array COMMAN sec_array

   85 matrix: LR sec_array RR

   86 declare: ID LR DOUBLE RR LR DOUBLE RR ASIG matrix


Rules useless in parser due to conflicts

   71 asig: ID ASIG ID

   79 function: FUN ID LG id_sec RG LF END bloque RF


State 41 conflicts: 1 shift/reduce
State 74 conflicts: 2 reduce/reduce
State 75 conflicts: 8 reduce/reduce
State 180 conflicts: 1 reduce/reduce


Grammar

    0 $accept: prog $end

    1 prog: stmts

    2 stmts: %empty
    3      | stat END stmts
    4      | END stmts
    5      | function END stmts

    6 expr: expr ADD expr
    7     | expr SUB expr
    8     | expr MUL expr
    9     | expr DIV expr
   10     | expr POT expr
   11     | LG expr RG
   12     | SUB expr
   13     | DOUBLE

   14 expr_id: expr_id ADD expr_id
   15        | expr_id SUB expr_id
   16        | expr_id MUL expr_id
   17        | expr_id DIV expr_id
   18        | expr_id POT expr_id
   19        | LG expr_id RG
   20        | SUB expr_id
   21        | ID
   22        | DOUBLE

   23 stat: if_stat
   24     | for_stat
   25     | while_stat
   26     | print_stat
   27     | condition
   28     | declare
   29     | asig
   30     | cont
   31     | call_function
   32     | expr

   33 bloque: stat END bloque
   34       | %empty

   35 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont RG LF END bloque RF

   36 while_stat: WHILE LG condition RG LF END bloque RF

   37 print_stat: PRINT LG ID RG
   38           | PRINT LG expr RG

   39 condition: bool_cond AB AB condition
   40          | bool_cond OB OB condition
   41          | num_cond AB AB condition
   42          | num_cond OB OB condition
   43          | num_cond
   44          | bool_cond
   45          | TRUE

   46 bool_cond: ID
   47          | ID neq_eq TRUE
   48          | ID neq_eq FALSE
   49          | ID neq_eq ID

   50 neq_eq: EQ
   51       | NE

   52 num_cond: ID oper DOUBLE
   53         | ID oper ID

   54 oper: neq_eq
   55     | LT
   56     | LE
   57     | GE
   58     | GT

   59 cont: ADD ADD ID
   60     | SUB SUB ID
   61     | ID ADD ADD
   62     | ID SUB SUB

   63 sec_num: DOUBLE COMMAN sec_num
   64        | DOUBLE

   65 array: LR sec_num RR
   66      | LR RR

   67 declare: ID LR DOUBLE RR ASIG array
   68        | ID ASIG expr

   69 asig: ID LR DOUBLE RR LR DOUBLE RR ASIG expr
   70     | ID LR DOUBLE RR ASIG expr
   71     | ID ASIG ID
   72     | ID ASIG expr_id

   73 id_sec: ID COMMAN id_sec
   74       | ID
   75       | %empty

   76 function: FUN ID LG id_sec RG LF END bloque RETURN expr_id RF
   77         | FUN ID LG id_sec RG LF END bloque RETURN expr RF
   78         | FUN ID LG id_sec RG LF END bloque RF
   79         | FUN ID LG id_sec RG LF END bloque RF

   80 call_function: ID LG id_sec RG
   81              | ID LG sec_num RG

   82 if_stat: IF LG condition RG LF END bloque RF ELSE LF END bloque RF
   83        | IF LG condition RG LF END bloque RF


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    IF (258) 82 83
    ELSE (259) 82
    ID <name> (260) 21 37 46 47 48 49 52 53 59 60 61 62 67 68 69 70 71 72 73 74 76 77 78 79 80 81
    DOUBLE <real> (261) 13 22 52 63 64 67 69 70
    FOR (262) 35
    WHILE (263) 36
    COM (264)
    BCOM (265)
    LT (266) 55
    LE (267) 56
    EQ (268) 50
    NE (269) 51
    GT (270) 58
    GE (271) 57
    PRINT (272) 37 38
    LG (273) 11 19 35 36 37 38 76 77 78 79 80 81 82 83
    RG (274) 11 19 35 36 37 38 76 77 78 79 80 81 82 83
    LR (275) 65 66 67 69 70
    RR (276) 65 66 67 69 70
    AB (277) 39 41
    OB (278) 40 42
    ADD (279) 6 14 59 61
    SUB (280) 7 12 15 20 60 62
    MUL (281) 8 16
    DIV (282) 9 17
    POT (283) 10 18
    FALSE (284) 48
    TRUE (285) 45 47
    LF (286) 35 36 76 77 78 79 82 83
    RF (287) 35 36 76 77 78 79 82 83
    ASIG (288) 67 68 69 70 71 72
    RETURN (289) 76 77
    ARITOP (290)
    FUN (291) 76 77 78 79
    RELOP (292)
    GROUP (293)
    ARRAY (294)
    BINOP (295)
    FUNCTION (296)
    SEMICOLON (297) 35
    COMMAN (298) 63 73
    END (299) 3 4 5 33 35 36 76 77 78 79 82 83
    UMINUS (300)


Nonterminals, with rules where they appear

    $accept (46)
        on left: 0
    prog (47)
        on left: 1
        on right: 0
    stmts (48)
        on left: 2 3 4 5
        on right: 1 3 4 5
    expr <real> (49)
        on left: 6 7 8 9 10 11 12 13
        on right: 6 7 8 9 10 11 12 32 38 68 69 70 77
    expr_id (50)
        on left: 14 15 16 17 18 19 20 21 22
        on right: 14 15 16 17 18 19 20 72 76
    stat (51)
        on left: 23 24 25 26 27 28 29 30 31 32
        on right: 3 33
    bloque (52)
        on left: 33 34
        on right: 33 35 36 76 77 78 79 82 83
    for_stat (53)
        on left: 35
        on right: 24
    while_stat (54)
        on left: 36
        on right: 25
    print_stat (55)
        on left: 37 38
        on right: 26
    condition (56)
        on left: 39 40 41 42 43 44 45
        on right: 27 35 36 39 40 41 42 82 83
    bool_cond (57)
        on left: 46 47 48 49
        on right: 39 40 44
    neq_eq (58)
        on left: 50 51
        on right: 47 48 49 54
    num_cond (59)
        on left: 52 53
        on right: 41 42 43
    oper (60)
        on left: 54 55 56 57 58
        on right: 52 53
    cont (61)
        on left: 59 60 61 62
        on right: 30 35
    sec_num (62)
        on left: 63 64
        on right: 63 65 81
    array (63)
        on left: 65 66
        on right: 67
    declare (64)
        on left: 67 68
        on right: 28
    asig (65)
        on left: 69 70 71 72
        on right: 29 35
    id_sec (66)
        on left: 73 74 75
        on right: 73 76 77 78 79 80
    function (67)
        on left: 76 77 78 79
        on right: 5
    call_function (68)
        on left: 80 81
        on right: 31
    if_stat (69)
        on left: 82 83
        on right: 23


State 0

    0 $accept: . prog $end

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10
    FUN     shift, and go to state 11
    END     shift, and go to state 12

    $default  reduce using rule 2 (stmts)

    prog           go to state 13
    stmts          go to state 14
    expr           go to state 15
    stat           go to state 16
    for_stat       go to state 17
    while_stat     go to state 18
    print_stat     go to state 19
    condition      go to state 20
    bool_cond      go to state 21
    num_cond       go to state 22
    cont           go to state 23
    declare        go to state 24
    asig           go to state 25
    function       go to state 26
    call_function  go to state 27
    if_stat        go to state 28


State 1

   82 if_stat: IF . LG condition RG LF END bloque RF ELSE LF END bloque RF
   83        | IF . LG condition RG LF END bloque RF

    LG  shift, and go to state 29


State 2

   46 bool_cond: ID .
   47          | ID . neq_eq TRUE
   48          | ID . neq_eq FALSE
   49          | ID . neq_eq ID
   52 num_cond: ID . oper DOUBLE
   53         | ID . oper ID
   61 cont: ID . ADD ADD
   62     | ID . SUB SUB
   67 declare: ID . LR DOUBLE RR ASIG array
   68        | ID . ASIG expr
   69 asig: ID . LR DOUBLE RR LR DOUBLE RR ASIG expr
   70     | ID . LR DOUBLE RR ASIG expr
   71     | ID . ASIG ID
   72     | ID . ASIG expr_id
   80 call_function: ID . LG id_sec RG
   81              | ID . LG sec_num RG

    LT    shift, and go to state 30
    LE    shift, and go to state 31
    EQ    shift, and go to state 32
    NE    shift, and go to state 33
    GT    shift, and go to state 34
    GE    shift, and go to state 35
    LG    shift, and go to state 36
    LR    shift, and go to state 37
    ADD   shift, and go to state 38
    SUB   shift, and go to state 39
    ASIG  shift, and go to state 40

    $default  reduce using rule 46 (bool_cond)

    neq_eq  go to state 41
    oper    go to state 42


State 3

   13 expr: DOUBLE .

    $default  reduce using rule 13 (expr)


State 4

   35 for_stat: FOR . LG asig SEMICOLON condition SEMICOLON cont RG LF END bloque RF

    LG  shift, and go to state 43


State 5

   36 while_stat: WHILE . LG condition RG LF END bloque RF

    LG  shift, and go to state 44


State 6

   37 print_stat: PRINT . LG ID RG
   38           | PRINT . LG expr RG

    LG  shift, and go to state 45


State 7

   11 expr: LG . expr RG

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 46

    expr  go to state 47


State 8

   59 cont: ADD . ADD ID

    ADD  shift, and go to state 48


State 9

   12 expr: SUB . expr
   60 cont: SUB . SUB ID

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 49

    expr  go to state 50


State 10

   45 condition: TRUE .

    $default  reduce using rule 45 (condition)


State 11

   76 function: FUN . ID LG id_sec RG LF END bloque RETURN expr_id RF
   77         | FUN . ID LG id_sec RG LF END bloque RETURN expr RF
   78         | FUN . ID LG id_sec RG LF END bloque RF
   79         | FUN . ID LG id_sec RG LF END bloque RF

    ID  shift, and go to state 51


State 12

    4 stmts: END . stmts

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10
    FUN     shift, and go to state 11
    END     shift, and go to state 12

    $default  reduce using rule 2 (stmts)

    stmts          go to state 52
    expr           go to state 15
    stat           go to state 16
    for_stat       go to state 17
    while_stat     go to state 18
    print_stat     go to state 19
    condition      go to state 20
    bool_cond      go to state 21
    num_cond       go to state 22
    cont           go to state 23
    declare        go to state 24
    asig           go to state 25
    function       go to state 26
    call_function  go to state 27
    if_stat        go to state 28


State 13

    0 $accept: prog . $end

    $end  shift, and go to state 53


State 14

    1 prog: stmts .

    $default  reduce using rule 1 (prog)


State 15

    6 expr: expr . ADD expr
    7     | expr . SUB expr
    8     | expr . MUL expr
    9     | expr . DIV expr
   10     | expr . POT expr
   32 stat: expr .

    ADD  shift, and go to state 54
    SUB  shift, and go to state 55
    MUL  shift, and go to state 56
    DIV  shift, and go to state 57
    POT  shift, and go to state 58

    $default  reduce using rule 32 (stat)


State 16

    3 stmts: stat . END stmts

    END  shift, and go to state 59


State 17

   24 stat: for_stat .

    $default  reduce using rule 24 (stat)


State 18

   25 stat: while_stat .

    $default  reduce using rule 25 (stat)


State 19

   26 stat: print_stat .

    $default  reduce using rule 26 (stat)


State 20

   27 stat: condition .

    $default  reduce using rule 27 (stat)


State 21

   39 condition: bool_cond . AB AB condition
   40          | bool_cond . OB OB condition
   44          | bool_cond .

    AB  shift, and go to state 60
    OB  shift, and go to state 61

    $default  reduce using rule 44 (condition)


State 22

   41 condition: num_cond . AB AB condition
   42          | num_cond . OB OB condition
   43          | num_cond .

    AB  shift, and go to state 62
    OB  shift, and go to state 63

    $default  reduce using rule 43 (condition)


State 23

   30 stat: cont .

    $default  reduce using rule 30 (stat)


State 24

   28 stat: declare .

    $default  reduce using rule 28 (stat)


State 25

   29 stat: asig .

    $default  reduce using rule 29 (stat)


State 26

    5 stmts: function . END stmts

    END  shift, and go to state 64


State 27

   31 stat: call_function .

    $default  reduce using rule 31 (stat)


State 28

   23 stat: if_stat .

    $default  reduce using rule 23 (stat)


State 29

   82 if_stat: IF LG . condition RG LF END bloque RF ELSE LF END bloque RF
   83        | IF LG . condition RG LF END bloque RF

    ID    shift, and go to state 65
    TRUE  shift, and go to state 10

    condition  go to state 66
    bool_cond  go to state 21
    num_cond   go to state 22


State 30

   55 oper: LT .

    $default  reduce using rule 55 (oper)


State 31

   56 oper: LE .

    $default  reduce using rule 56 (oper)


State 32

   50 neq_eq: EQ .

    $default  reduce using rule 50 (neq_eq)


State 33

   51 neq_eq: NE .

    $default  reduce using rule 51 (neq_eq)


State 34

   58 oper: GT .

    $default  reduce using rule 58 (oper)


State 35

   57 oper: GE .

    $default  reduce using rule 57 (oper)


State 36

   80 call_function: ID LG . id_sec RG
   81              | ID LG . sec_num RG

    ID      shift, and go to state 67
    DOUBLE  shift, and go to state 68

    $default  reduce using rule 75 (id_sec)

    sec_num  go to state 69
    id_sec   go to state 70


State 37

   67 declare: ID LR . DOUBLE RR ASIG array
   69 asig: ID LR . DOUBLE RR LR DOUBLE RR ASIG expr
   70     | ID LR . DOUBLE RR ASIG expr

    DOUBLE  shift, and go to state 71


State 38

   61 cont: ID ADD . ADD

    ADD  shift, and go to state 72


State 39

   62 cont: ID SUB . SUB

    SUB  shift, and go to state 73


State 40

   68 declare: ID ASIG . expr
   71 asig: ID ASIG . ID
   72     | ID ASIG . expr_id

    ID      shift, and go to state 74
    DOUBLE  shift, and go to state 75
    LG      shift, and go to state 76
    SUB     shift, and go to state 77

    expr     go to state 78
    expr_id  go to state 79


State 41

   47 bool_cond: ID neq_eq . TRUE
   48          | ID neq_eq . FALSE
   49          | ID neq_eq . ID
   54 oper: neq_eq .

    ID     shift, and go to state 80
    FALSE  shift, and go to state 81
    TRUE   shift, and go to state 82

    ID        [reduce using rule 54 (oper)]
    $default  reduce using rule 54 (oper)


State 42

   52 num_cond: ID oper . DOUBLE
   53         | ID oper . ID

    ID      shift, and go to state 83
    DOUBLE  shift, and go to state 84


State 43

   35 for_stat: FOR LG . asig SEMICOLON condition SEMICOLON cont RG LF END bloque RF

    ID  shift, and go to state 85

    asig  go to state 86


State 44

   36 while_stat: WHILE LG . condition RG LF END bloque RF

    ID    shift, and go to state 65
    TRUE  shift, and go to state 10

    condition  go to state 87
    bool_cond  go to state 21
    num_cond   go to state 22


State 45

   37 print_stat: PRINT LG . ID RG
   38           | PRINT LG . expr RG

    ID      shift, and go to state 88
    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 46

    expr  go to state 89


State 46

   12 expr: SUB . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 46

    expr  go to state 50


State 47

    6 expr: expr . ADD expr
    7     | expr . SUB expr
    8     | expr . MUL expr
    9     | expr . DIV expr
   10     | expr . POT expr
   11     | LG expr . RG

    RG   shift, and go to state 90
    ADD  shift, and go to state 54
    SUB  shift, and go to state 55
    MUL  shift, and go to state 56
    DIV  shift, and go to state 57
    POT  shift, and go to state 58


State 48

   59 cont: ADD ADD . ID

    ID  shift, and go to state 91


State 49

   12 expr: SUB . expr
   60 cont: SUB SUB . ID

    ID      shift, and go to state 92
    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 46

    expr  go to state 50


State 50

    6 expr: expr . ADD expr
    7     | expr . SUB expr
    8     | expr . MUL expr
    9     | expr . DIV expr
   10     | expr . POT expr
   12     | SUB expr .

    $default  reduce using rule 12 (expr)


State 51

   76 function: FUN ID . LG id_sec RG LF END bloque RETURN expr_id RF
   77         | FUN ID . LG id_sec RG LF END bloque RETURN expr RF
   78         | FUN ID . LG id_sec RG LF END bloque RF
   79         | FUN ID . LG id_sec RG LF END bloque RF

    LG  shift, and go to state 93


State 52

    4 stmts: END stmts .

    $default  reduce using rule 4 (stmts)


State 53

    0 $accept: prog $end .

    $default  accept


State 54

    6 expr: expr ADD . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 46

    expr  go to state 94


State 55

    7 expr: expr SUB . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 46

    expr  go to state 95


State 56

    8 expr: expr MUL . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 46

    expr  go to state 96


State 57

    9 expr: expr DIV . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 46

    expr  go to state 97


State 58

   10 expr: expr POT . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 46

    expr  go to state 98


State 59

    3 stmts: stat END . stmts

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10
    FUN     shift, and go to state 11
    END     shift, and go to state 12

    $default  reduce using rule 2 (stmts)

    stmts          go to state 99
    expr           go to state 15
    stat           go to state 16
    for_stat       go to state 17
    while_stat     go to state 18
    print_stat     go to state 19
    condition      go to state 20
    bool_cond      go to state 21
    num_cond       go to state 22
    cont           go to state 23
    declare        go to state 24
    asig           go to state 25
    function       go to state 26
    call_function  go to state 27
    if_stat        go to state 28


State 60

   39 condition: bool_cond AB . AB condition

    AB  shift, and go to state 100


State 61

   40 condition: bool_cond OB . OB condition

    OB  shift, and go to state 101


State 62

   41 condition: num_cond AB . AB condition

    AB  shift, and go to state 102


State 63

   42 condition: num_cond OB . OB condition

    OB  shift, and go to state 103


State 64

    5 stmts: function END . stmts

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10
    FUN     shift, and go to state 11
    END     shift, and go to state 12

    $default  reduce using rule 2 (stmts)

    stmts          go to state 104
    expr           go to state 15
    stat           go to state 16
    for_stat       go to state 17
    while_stat     go to state 18
    print_stat     go to state 19
    condition      go to state 20
    bool_cond      go to state 21
    num_cond       go to state 22
    cont           go to state 23
    declare        go to state 24
    asig           go to state 25
    function       go to state 26
    call_function  go to state 27
    if_stat        go to state 28


State 65

   46 bool_cond: ID .
   47          | ID . neq_eq TRUE
   48          | ID . neq_eq FALSE
   49          | ID . neq_eq ID
   52 num_cond: ID . oper DOUBLE
   53         | ID . oper ID

    LT  shift, and go to state 30
    LE  shift, and go to state 31
    EQ  shift, and go to state 32
    NE  shift, and go to state 33
    GT  shift, and go to state 34
    GE  shift, and go to state 35

    $default  reduce using rule 46 (bool_cond)

    neq_eq  go to state 41
    oper    go to state 42


State 66

   82 if_stat: IF LG condition . RG LF END bloque RF ELSE LF END bloque RF
   83        | IF LG condition . RG LF END bloque RF

    RG  shift, and go to state 105


State 67

   73 id_sec: ID . COMMAN id_sec
   74       | ID .

    COMMAN  shift, and go to state 106

    $default  reduce using rule 74 (id_sec)


State 68

   63 sec_num: DOUBLE . COMMAN sec_num
   64        | DOUBLE .

    COMMAN  shift, and go to state 107

    $default  reduce using rule 64 (sec_num)


State 69

   81 call_function: ID LG sec_num . RG

    RG  shift, and go to state 108


State 70

   80 call_function: ID LG id_sec . RG

    RG  shift, and go to state 109


State 71

   67 declare: ID LR DOUBLE . RR ASIG array
   69 asig: ID LR DOUBLE . RR LR DOUBLE RR ASIG expr
   70     | ID LR DOUBLE . RR ASIG expr

    RR  shift, and go to state 110


State 72

   61 cont: ID ADD ADD .

    $default  reduce using rule 61 (cont)


State 73

   62 cont: ID SUB SUB .

    $default  reduce using rule 62 (cont)


State 74

   21 expr_id: ID .
   71 asig: ID ASIG ID .

    SEMICOLON  reduce using rule 21 (expr_id)
    SEMICOLON  [reduce using rule 71 (asig)]
    END        reduce using rule 21 (expr_id)
    END        [reduce using rule 71 (asig)]
    $default   reduce using rule 21 (expr_id)


State 75

   13 expr: DOUBLE .
   22 expr_id: DOUBLE .

    RG        reduce using rule 13 (expr)
    RG        [reduce using rule 22 (expr_id)]
    ADD       reduce using rule 13 (expr)
    ADD       [reduce using rule 22 (expr_id)]
    SUB       reduce using rule 13 (expr)
    SUB       [reduce using rule 22 (expr_id)]
    MUL       reduce using rule 13 (expr)
    MUL       [reduce using rule 22 (expr_id)]
    DIV       reduce using rule 13 (expr)
    DIV       [reduce using rule 22 (expr_id)]
    POT       reduce using rule 13 (expr)
    POT       [reduce using rule 22 (expr_id)]
    RF        reduce using rule 13 (expr)
    RF        [reduce using rule 22 (expr_id)]
    END       reduce using rule 13 (expr)
    END       [reduce using rule 22 (expr_id)]
    $default  reduce using rule 13 (expr)


State 76

   11 expr: LG . expr RG
   19 expr_id: LG . expr_id RG

    ID      shift, and go to state 111
    DOUBLE  shift, and go to state 75
    LG      shift, and go to state 76
    SUB     shift, and go to state 77

    expr     go to state 47
    expr_id  go to state 112


State 77

   12 expr: SUB . expr
   20 expr_id: SUB . expr_id

    ID      shift, and go to state 111
    DOUBLE  shift, and go to state 75
    LG      shift, and go to state 76
    SUB     shift, and go to state 77

    expr     go to state 50
    expr_id  go to state 113


State 78

    6 expr: expr . ADD expr
    7     | expr . SUB expr
    8     | expr . MUL expr
    9     | expr . DIV expr
   10     | expr . POT expr
   68 declare: ID ASIG expr .

    ADD  shift, and go to state 54
    SUB  shift, and go to state 55
    MUL  shift, and go to state 56
    DIV  shift, and go to state 57
    POT  shift, and go to state 58

    $default  reduce using rule 68 (declare)


State 79

   14 expr_id: expr_id . ADD expr_id
   15        | expr_id . SUB expr_id
   16        | expr_id . MUL expr_id
   17        | expr_id . DIV expr_id
   18        | expr_id . POT expr_id
   72 asig: ID ASIG expr_id .

    ADD  shift, and go to state 114
    SUB  shift, and go to state 115
    MUL  shift, and go to state 116
    DIV  shift, and go to state 117
    POT  shift, and go to state 118

    $default  reduce using rule 72 (asig)


State 80

   49 bool_cond: ID neq_eq ID .

    $default  reduce using rule 49 (bool_cond)


State 81

   48 bool_cond: ID neq_eq FALSE .

    $default  reduce using rule 48 (bool_cond)


State 82

   47 bool_cond: ID neq_eq TRUE .

    $default  reduce using rule 47 (bool_cond)


State 83

   53 num_cond: ID oper ID .

    $default  reduce using rule 53 (num_cond)


State 84

   52 num_cond: ID oper DOUBLE .

    $default  reduce using rule 52 (num_cond)


State 85

   69 asig: ID . LR DOUBLE RR LR DOUBLE RR ASIG expr
   70     | ID . LR DOUBLE RR ASIG expr
   71     | ID . ASIG ID
   72     | ID . ASIG expr_id

    LR    shift, and go to state 119
    ASIG  shift, and go to state 120


State 86

   35 for_stat: FOR LG asig . SEMICOLON condition SEMICOLON cont RG LF END bloque RF

    SEMICOLON  shift, and go to state 121


State 87

   36 while_stat: WHILE LG condition . RG LF END bloque RF

    RG  shift, and go to state 122


State 88

   37 print_stat: PRINT LG ID . RG

    RG  shift, and go to state 123


State 89

    6 expr: expr . ADD expr
    7     | expr . SUB expr
    8     | expr . MUL expr
    9     | expr . DIV expr
   10     | expr . POT expr
   38 print_stat: PRINT LG expr . RG

    RG   shift, and go to state 124
    ADD  shift, and go to state 54
    SUB  shift, and go to state 55
    MUL  shift, and go to state 56
    DIV  shift, and go to state 57
    POT  shift, and go to state 58


State 90

   11 expr: LG expr RG .

    $default  reduce using rule 11 (expr)


State 91

   59 cont: ADD ADD ID .

    $default  reduce using rule 59 (cont)


State 92

   60 cont: SUB SUB ID .

    $default  reduce using rule 60 (cont)


State 93

   76 function: FUN ID LG . id_sec RG LF END bloque RETURN expr_id RF
   77         | FUN ID LG . id_sec RG LF END bloque RETURN expr RF
   78         | FUN ID LG . id_sec RG LF END bloque RF
   79         | FUN ID LG . id_sec RG LF END bloque RF

    ID  shift, and go to state 67

    $default  reduce using rule 75 (id_sec)

    id_sec  go to state 125


State 94

    6 expr: expr . ADD expr
    6     | expr ADD expr .
    7     | expr . SUB expr
    8     | expr . MUL expr
    9     | expr . DIV expr
   10     | expr . POT expr

    MUL  shift, and go to state 56
    DIV  shift, and go to state 57
    POT  shift, and go to state 58

    $default  reduce using rule 6 (expr)


State 95

    6 expr: expr . ADD expr
    7     | expr . SUB expr
    7     | expr SUB expr .
    8     | expr . MUL expr
    9     | expr . DIV expr
   10     | expr . POT expr

    MUL  shift, and go to state 56
    DIV  shift, and go to state 57
    POT  shift, and go to state 58

    $default  reduce using rule 7 (expr)


State 96

    6 expr: expr . ADD expr
    7     | expr . SUB expr
    8     | expr . MUL expr
    8     | expr MUL expr .
    9     | expr . DIV expr
   10     | expr . POT expr

    POT  shift, and go to state 58

    $default  reduce using rule 8 (expr)


State 97

    6 expr: expr . ADD expr
    7     | expr . SUB expr
    8     | expr . MUL expr
    9     | expr . DIV expr
    9     | expr DIV expr .
   10     | expr . POT expr

    POT  shift, and go to state 58

    $default  reduce using rule 9 (expr)


State 98

    6 expr: expr . ADD expr
    7     | expr . SUB expr
    8     | expr . MUL expr
    9     | expr . DIV expr
   10     | expr . POT expr
   10     | expr POT expr .

    POT  shift, and go to state 58

    $default  reduce using rule 10 (expr)


State 99

    3 stmts: stat END stmts .

    $default  reduce using rule 3 (stmts)


State 100

   39 condition: bool_cond AB AB . condition

    ID    shift, and go to state 65
    TRUE  shift, and go to state 10

    condition  go to state 126
    bool_cond  go to state 21
    num_cond   go to state 22


State 101

   40 condition: bool_cond OB OB . condition

    ID    shift, and go to state 65
    TRUE  shift, and go to state 10

    condition  go to state 127
    bool_cond  go to state 21
    num_cond   go to state 22


State 102

   41 condition: num_cond AB AB . condition

    ID    shift, and go to state 65
    TRUE  shift, and go to state 10

    condition  go to state 128
    bool_cond  go to state 21
    num_cond   go to state 22


State 103

   42 condition: num_cond OB OB . condition

    ID    shift, and go to state 65
    TRUE  shift, and go to state 10

    condition  go to state 129
    bool_cond  go to state 21
    num_cond   go to state 22


State 104

    5 stmts: function END stmts .

    $default  reduce using rule 5 (stmts)


State 105

   82 if_stat: IF LG condition RG . LF END bloque RF ELSE LF END bloque RF
   83        | IF LG condition RG . LF END bloque RF

    LF  shift, and go to state 130


State 106

   73 id_sec: ID COMMAN . id_sec

    ID  shift, and go to state 67

    $default  reduce using rule 75 (id_sec)

    id_sec  go to state 131


State 107

   63 sec_num: DOUBLE COMMAN . sec_num

    DOUBLE  shift, and go to state 68

    sec_num  go to state 132


State 108

   81 call_function: ID LG sec_num RG .

    $default  reduce using rule 81 (call_function)


State 109

   80 call_function: ID LG id_sec RG .

    $default  reduce using rule 80 (call_function)


State 110

   67 declare: ID LR DOUBLE RR . ASIG array
   69 asig: ID LR DOUBLE RR . LR DOUBLE RR ASIG expr
   70     | ID LR DOUBLE RR . ASIG expr

    LR    shift, and go to state 133
    ASIG  shift, and go to state 134


State 111

   21 expr_id: ID .

    $default  reduce using rule 21 (expr_id)


State 112

   14 expr_id: expr_id . ADD expr_id
   15        | expr_id . SUB expr_id
   16        | expr_id . MUL expr_id
   17        | expr_id . DIV expr_id
   18        | expr_id . POT expr_id
   19        | LG expr_id . RG

    RG   shift, and go to state 135
    ADD  shift, and go to state 114
    SUB  shift, and go to state 115
    MUL  shift, and go to state 116
    DIV  shift, and go to state 117
    POT  shift, and go to state 118


State 113

   14 expr_id: expr_id . ADD expr_id
   15        | expr_id . SUB expr_id
   16        | expr_id . MUL expr_id
   17        | expr_id . DIV expr_id
   18        | expr_id . POT expr_id
   20        | SUB expr_id .

    $default  reduce using rule 20 (expr_id)


State 114

   14 expr_id: expr_id ADD . expr_id

    ID      shift, and go to state 111
    DOUBLE  shift, and go to state 136
    LG      shift, and go to state 137
    SUB     shift, and go to state 138

    expr_id  go to state 139


State 115

   15 expr_id: expr_id SUB . expr_id

    ID      shift, and go to state 111
    DOUBLE  shift, and go to state 136
    LG      shift, and go to state 137
    SUB     shift, and go to state 138

    expr_id  go to state 140


State 116

   16 expr_id: expr_id MUL . expr_id

    ID      shift, and go to state 111
    DOUBLE  shift, and go to state 136
    LG      shift, and go to state 137
    SUB     shift, and go to state 138

    expr_id  go to state 141


State 117

   17 expr_id: expr_id DIV . expr_id

    ID      shift, and go to state 111
    DOUBLE  shift, and go to state 136
    LG      shift, and go to state 137
    SUB     shift, and go to state 138

    expr_id  go to state 142


State 118

   18 expr_id: expr_id POT . expr_id

    ID      shift, and go to state 111
    DOUBLE  shift, and go to state 136
    LG      shift, and go to state 137
    SUB     shift, and go to state 138

    expr_id  go to state 143


State 119

   69 asig: ID LR . DOUBLE RR LR DOUBLE RR ASIG expr
   70     | ID LR . DOUBLE RR ASIG expr

    DOUBLE  shift, and go to state 144


State 120

   71 asig: ID ASIG . ID
   72     | ID ASIG . expr_id

    ID      shift, and go to state 74
    DOUBLE  shift, and go to state 136
    LG      shift, and go to state 137
    SUB     shift, and go to state 138

    expr_id  go to state 79


State 121

   35 for_stat: FOR LG asig SEMICOLON . condition SEMICOLON cont RG LF END bloque RF

    ID    shift, and go to state 65
    TRUE  shift, and go to state 10

    condition  go to state 145
    bool_cond  go to state 21
    num_cond   go to state 22


State 122

   36 while_stat: WHILE LG condition RG . LF END bloque RF

    LF  shift, and go to state 146


State 123

   37 print_stat: PRINT LG ID RG .

    $default  reduce using rule 37 (print_stat)


State 124

   38 print_stat: PRINT LG expr RG .

    $default  reduce using rule 38 (print_stat)


State 125

   76 function: FUN ID LG id_sec . RG LF END bloque RETURN expr_id RF
   77         | FUN ID LG id_sec . RG LF END bloque RETURN expr RF
   78         | FUN ID LG id_sec . RG LF END bloque RF
   79         | FUN ID LG id_sec . RG LF END bloque RF

    RG  shift, and go to state 147


State 126

   39 condition: bool_cond AB AB condition .

    $default  reduce using rule 39 (condition)


State 127

   40 condition: bool_cond OB OB condition .

    $default  reduce using rule 40 (condition)


State 128

   41 condition: num_cond AB AB condition .

    $default  reduce using rule 41 (condition)


State 129

   42 condition: num_cond OB OB condition .

    $default  reduce using rule 42 (condition)


State 130

   82 if_stat: IF LG condition RG LF . END bloque RF ELSE LF END bloque RF
   83        | IF LG condition RG LF . END bloque RF

    END  shift, and go to state 148


State 131

   73 id_sec: ID COMMAN id_sec .

    $default  reduce using rule 73 (id_sec)


State 132

   63 sec_num: DOUBLE COMMAN sec_num .

    $default  reduce using rule 63 (sec_num)


State 133

   69 asig: ID LR DOUBLE RR LR . DOUBLE RR ASIG expr

    DOUBLE  shift, and go to state 149


State 134

   67 declare: ID LR DOUBLE RR ASIG . array
   70 asig: ID LR DOUBLE RR ASIG . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    LR      shift, and go to state 150
    SUB     shift, and go to state 46

    expr   go to state 151
    array  go to state 152


State 135

   19 expr_id: LG expr_id RG .

    $default  reduce using rule 19 (expr_id)


State 136

   22 expr_id: DOUBLE .

    $default  reduce using rule 22 (expr_id)


State 137

   19 expr_id: LG . expr_id RG

    ID      shift, and go to state 111
    DOUBLE  shift, and go to state 136
    LG      shift, and go to state 137
    SUB     shift, and go to state 138

    expr_id  go to state 112


State 138

   20 expr_id: SUB . expr_id

    ID      shift, and go to state 111
    DOUBLE  shift, and go to state 136
    LG      shift, and go to state 137
    SUB     shift, and go to state 138

    expr_id  go to state 113


State 139

   14 expr_id: expr_id . ADD expr_id
   14        | expr_id ADD expr_id .
   15        | expr_id . SUB expr_id
   16        | expr_id . MUL expr_id
   17        | expr_id . DIV expr_id
   18        | expr_id . POT expr_id

    MUL  shift, and go to state 116
    DIV  shift, and go to state 117
    POT  shift, and go to state 118

    $default  reduce using rule 14 (expr_id)


State 140

   14 expr_id: expr_id . ADD expr_id
   15        | expr_id . SUB expr_id
   15        | expr_id SUB expr_id .
   16        | expr_id . MUL expr_id
   17        | expr_id . DIV expr_id
   18        | expr_id . POT expr_id

    MUL  shift, and go to state 116
    DIV  shift, and go to state 117
    POT  shift, and go to state 118

    $default  reduce using rule 15 (expr_id)


State 141

   14 expr_id: expr_id . ADD expr_id
   15        | expr_id . SUB expr_id
   16        | expr_id . MUL expr_id
   16        | expr_id MUL expr_id .
   17        | expr_id . DIV expr_id
   18        | expr_id . POT expr_id

    POT  shift, and go to state 118

    $default  reduce using rule 16 (expr_id)


State 142

   14 expr_id: expr_id . ADD expr_id
   15        | expr_id . SUB expr_id
   16        | expr_id . MUL expr_id
   17        | expr_id . DIV expr_id
   17        | expr_id DIV expr_id .
   18        | expr_id . POT expr_id

    POT  shift, and go to state 118

    $default  reduce using rule 17 (expr_id)


State 143

   14 expr_id: expr_id . ADD expr_id
   15        | expr_id . SUB expr_id
   16        | expr_id . MUL expr_id
   17        | expr_id . DIV expr_id
   18        | expr_id . POT expr_id
   18        | expr_id POT expr_id .

    POT  shift, and go to state 118

    $default  reduce using rule 18 (expr_id)


State 144

   69 asig: ID LR DOUBLE . RR LR DOUBLE RR ASIG expr
   70     | ID LR DOUBLE . RR ASIG expr

    RR  shift, and go to state 153


State 145

   35 for_stat: FOR LG asig SEMICOLON condition . SEMICOLON cont RG LF END bloque RF

    SEMICOLON  shift, and go to state 154


State 146

   36 while_stat: WHILE LG condition RG LF . END bloque RF

    END  shift, and go to state 155


State 147

   76 function: FUN ID LG id_sec RG . LF END bloque RETURN expr_id RF
   77         | FUN ID LG id_sec RG . LF END bloque RETURN expr RF
   78         | FUN ID LG id_sec RG . LF END bloque RF
   79         | FUN ID LG id_sec RG . LF END bloque RF

    LF  shift, and go to state 156


State 148

   82 if_stat: IF LG condition RG LF END . bloque RF ELSE LF END bloque RF
   83        | IF LG condition RG LF END . bloque RF

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10

    $default  reduce using rule 34 (bloque)

    expr           go to state 15
    stat           go to state 157
    bloque         go to state 158
    for_stat       go to state 17
    while_stat     go to state 18
    print_stat     go to state 19
    condition      go to state 20
    bool_cond      go to state 21
    num_cond       go to state 22
    cont           go to state 23
    declare        go to state 24
    asig           go to state 25
    call_function  go to state 27
    if_stat        go to state 28


State 149

   69 asig: ID LR DOUBLE RR LR DOUBLE . RR ASIG expr

    RR  shift, and go to state 159


State 150

   65 array: LR . sec_num RR
   66      | LR . RR

    DOUBLE  shift, and go to state 68
    RR      shift, and go to state 160

    sec_num  go to state 161


State 151

    6 expr: expr . ADD expr
    7     | expr . SUB expr
    8     | expr . MUL expr
    9     | expr . DIV expr
   10     | expr . POT expr
   70 asig: ID LR DOUBLE RR ASIG expr .

    ADD  shift, and go to state 54
    SUB  shift, and go to state 55
    MUL  shift, and go to state 56
    DIV  shift, and go to state 57
    POT  shift, and go to state 58

    $default  reduce using rule 70 (asig)


State 152

   67 declare: ID LR DOUBLE RR ASIG array .

    $default  reduce using rule 67 (declare)


State 153

   69 asig: ID LR DOUBLE RR . LR DOUBLE RR ASIG expr
   70     | ID LR DOUBLE RR . ASIG expr

    LR    shift, and go to state 133
    ASIG  shift, and go to state 162


State 154

   35 for_stat: FOR LG asig SEMICOLON condition SEMICOLON . cont RG LF END bloque RF

    ID   shift, and go to state 163
    ADD  shift, and go to state 8
    SUB  shift, and go to state 164

    cont  go to state 165


State 155

   36 while_stat: WHILE LG condition RG LF END . bloque RF

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10

    $default  reduce using rule 34 (bloque)

    expr           go to state 15
    stat           go to state 157
    bloque         go to state 166
    for_stat       go to state 17
    while_stat     go to state 18
    print_stat     go to state 19
    condition      go to state 20
    bool_cond      go to state 21
    num_cond       go to state 22
    cont           go to state 23
    declare        go to state 24
    asig           go to state 25
    call_function  go to state 27
    if_stat        go to state 28


State 156

   76 function: FUN ID LG id_sec RG LF . END bloque RETURN expr_id RF
   77         | FUN ID LG id_sec RG LF . END bloque RETURN expr RF
   78         | FUN ID LG id_sec RG LF . END bloque RF
   79         | FUN ID LG id_sec RG LF . END bloque RF

    END  shift, and go to state 167


State 157

   33 bloque: stat . END bloque

    END  shift, and go to state 168


State 158

   82 if_stat: IF LG condition RG LF END bloque . RF ELSE LF END bloque RF
   83        | IF LG condition RG LF END bloque . RF

    RF  shift, and go to state 169


State 159

   69 asig: ID LR DOUBLE RR LR DOUBLE RR . ASIG expr

    ASIG  shift, and go to state 170


State 160

   66 array: LR RR .

    $default  reduce using rule 66 (array)


State 161

   65 array: LR sec_num . RR

    RR  shift, and go to state 171


State 162

   70 asig: ID LR DOUBLE RR ASIG . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 46

    expr  go to state 151


State 163

   61 cont: ID . ADD ADD
   62     | ID . SUB SUB

    ADD  shift, and go to state 38
    SUB  shift, and go to state 39


State 164

   60 cont: SUB . SUB ID

    SUB  shift, and go to state 172


State 165

   35 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont . RG LF END bloque RF

    RG  shift, and go to state 173


State 166

   36 while_stat: WHILE LG condition RG LF END bloque . RF

    RF  shift, and go to state 174


State 167

   76 function: FUN ID LG id_sec RG LF END . bloque RETURN expr_id RF
   77         | FUN ID LG id_sec RG LF END . bloque RETURN expr RF
   78         | FUN ID LG id_sec RG LF END . bloque RF
   79         | FUN ID LG id_sec RG LF END . bloque RF

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10

    $default  reduce using rule 34 (bloque)

    expr           go to state 15
    stat           go to state 157
    bloque         go to state 175
    for_stat       go to state 17
    while_stat     go to state 18
    print_stat     go to state 19
    condition      go to state 20
    bool_cond      go to state 21
    num_cond       go to state 22
    cont           go to state 23
    declare        go to state 24
    asig           go to state 25
    call_function  go to state 27
    if_stat        go to state 28


State 168

   33 bloque: stat END . bloque

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10

    $default  reduce using rule 34 (bloque)

    expr           go to state 15
    stat           go to state 157
    bloque         go to state 176
    for_stat       go to state 17
    while_stat     go to state 18
    print_stat     go to state 19
    condition      go to state 20
    bool_cond      go to state 21
    num_cond       go to state 22
    cont           go to state 23
    declare        go to state 24
    asig           go to state 25
    call_function  go to state 27
    if_stat        go to state 28


State 169

   82 if_stat: IF LG condition RG LF END bloque RF . ELSE LF END bloque RF
   83        | IF LG condition RG LF END bloque RF .

    ELSE  shift, and go to state 177

    $default  reduce using rule 83 (if_stat)


State 170

   69 asig: ID LR DOUBLE RR LR DOUBLE RR ASIG . expr

    DOUBLE  shift, and go to state 3
    LG      shift, and go to state 7
    SUB     shift, and go to state 46

    expr  go to state 178


State 171

   65 array: LR sec_num RR .

    $default  reduce using rule 65 (array)


State 172

   60 cont: SUB SUB . ID

    ID  shift, and go to state 92


State 173

   35 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont RG . LF END bloque RF

    LF  shift, and go to state 179


State 174

   36 while_stat: WHILE LG condition RG LF END bloque RF .

    $default  reduce using rule 36 (while_stat)


State 175

   76 function: FUN ID LG id_sec RG LF END bloque . RETURN expr_id RF
   77         | FUN ID LG id_sec RG LF END bloque . RETURN expr RF
   78         | FUN ID LG id_sec RG LF END bloque . RF
   79         | FUN ID LG id_sec RG LF END bloque . RF

    RF      shift, and go to state 180
    RETURN  shift, and go to state 181


State 176

   33 bloque: stat END bloque .

    $default  reduce using rule 33 (bloque)


State 177

   82 if_stat: IF LG condition RG LF END bloque RF ELSE . LF END bloque RF

    LF  shift, and go to state 182


State 178

    6 expr: expr . ADD expr
    7     | expr . SUB expr
    8     | expr . MUL expr
    9     | expr . DIV expr
   10     | expr . POT expr
   69 asig: ID LR DOUBLE RR LR DOUBLE RR ASIG expr .

    ADD  shift, and go to state 54
    SUB  shift, and go to state 55
    MUL  shift, and go to state 56
    DIV  shift, and go to state 57
    POT  shift, and go to state 58

    $default  reduce using rule 69 (asig)


State 179

   35 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont RG LF . END bloque RF

    END  shift, and go to state 183


State 180

   78 function: FUN ID LG id_sec RG LF END bloque RF .
   79         | FUN ID LG id_sec RG LF END bloque RF .

    END       reduce using rule 78 (function)
    END       [reduce using rule 79 (function)]
    $default  reduce using rule 78 (function)


State 181

   76 function: FUN ID LG id_sec RG LF END bloque RETURN . expr_id RF
   77         | FUN ID LG id_sec RG LF END bloque RETURN . expr RF

    ID      shift, and go to state 111
    DOUBLE  shift, and go to state 75
    LG      shift, and go to state 76
    SUB     shift, and go to state 77

    expr     go to state 184
    expr_id  go to state 185


State 182

   82 if_stat: IF LG condition RG LF END bloque RF ELSE LF . END bloque RF

    END  shift, and go to state 186


State 183

   35 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont RG LF END . bloque RF

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10

    $default  reduce using rule 34 (bloque)

    expr           go to state 15
    stat           go to state 157
    bloque         go to state 187
    for_stat       go to state 17
    while_stat     go to state 18
    print_stat     go to state 19
    condition      go to state 20
    bool_cond      go to state 21
    num_cond       go to state 22
    cont           go to state 23
    declare        go to state 24
    asig           go to state 25
    call_function  go to state 27
    if_stat        go to state 28


State 184

    6 expr: expr . ADD expr
    7     | expr . SUB expr
    8     | expr . MUL expr
    9     | expr . DIV expr
   10     | expr . POT expr
   77 function: FUN ID LG id_sec RG LF END bloque RETURN expr . RF

    ADD  shift, and go to state 54
    SUB  shift, and go to state 55
    MUL  shift, and go to state 56
    DIV  shift, and go to state 57
    POT  shift, and go to state 58
    RF   shift, and go to state 188


State 185

   14 expr_id: expr_id . ADD expr_id
   15        | expr_id . SUB expr_id
   16        | expr_id . MUL expr_id
   17        | expr_id . DIV expr_id
   18        | expr_id . POT expr_id
   76 function: FUN ID LG id_sec RG LF END bloque RETURN expr_id . RF

    ADD  shift, and go to state 114
    SUB  shift, and go to state 115
    MUL  shift, and go to state 116
    DIV  shift, and go to state 117
    POT  shift, and go to state 118
    RF   shift, and go to state 189


State 186

   82 if_stat: IF LG condition RG LF END bloque RF ELSE LF END . bloque RF

    IF      shift, and go to state 1
    ID      shift, and go to state 2
    DOUBLE  shift, and go to state 3
    FOR     shift, and go to state 4
    WHILE   shift, and go to state 5
    PRINT   shift, and go to state 6
    LG      shift, and go to state 7
    ADD     shift, and go to state 8
    SUB     shift, and go to state 9
    TRUE    shift, and go to state 10

    $default  reduce using rule 34 (bloque)

    expr           go to state 15
    stat           go to state 157
    bloque         go to state 190
    for_stat       go to state 17
    while_stat     go to state 18
    print_stat     go to state 19
    condition      go to state 20
    bool_cond      go to state 21
    num_cond       go to state 22
    cont           go to state 23
    declare        go to state 24
    asig           go to state 25
    call_function  go to state 27
    if_stat        go to state 28


State 187

   35 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont RG LF END bloque . RF

    RF  shift, and go to state 191


State 188

   77 function: FUN ID LG id_sec RG LF END bloque RETURN expr RF .

    $default  reduce using rule 77 (function)


State 189

   76 function: FUN ID LG id_sec RG LF END bloque RETURN expr_id RF .

    $default  reduce using rule 76 (function)


State 190

   82 if_stat: IF LG condition RG LF END bloque RF ELSE LF END bloque . RF

    RF  shift, and go to state 192


State 191

   35 for_stat: FOR LG asig SEMICOLON condition SEMICOLON cont RG LF END bloque RF .

    $default  reduce using rule 35 (for_stat)


State 192

   82 if_stat: IF LG condition RG LF END bloque RF ELSE LF END bloque RF .

    $default  reduce using rule 82 (if_stat)
